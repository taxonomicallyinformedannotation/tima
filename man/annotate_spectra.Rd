% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/annotate_spectra.R
\name{annotate_spectra}
\alias{annotate_spectra}
\title{Annotate spectra}
\usage{
annotate_spectra(
  input = get_params(step = "annotate_spectra")$files$spectral$raw,
  libraries = get_params(step = "annotate_spectra")$files$libraries$spectral,
  polarity = get_params(step = "annotate_spectra")$ms$polarity,
  output = get_params(step = "annotate_spectra")$files$annotations$raw$spectral$spectral,
  method = get_params(step = "annotate_spectra")$similarities$methods$annotations,
  threshold = get_params(step = "annotate_spectra")$similarities$thresholds$annotations,
  ppm = get_params(step = "annotate_spectra")$ms$tolerances$mass$ppm$ms2,
  dalton = get_params(step = "annotate_spectra")$ms$tolerances$mass$dalton$ms2,
  qutoff = get_params(step = "annotate_spectra")$ms$thresholds$ms2$intensity,
  approx = get_params(step = "annotate_spectra")$annotations$ms2approx
)
}
\arguments{
\item{input}{Character vector or list of query spectral file paths (.mgf).}

\item{libraries}{Character vector or list of library spectral file paths
(.mgf / Spectra-supported). Must contain at least one path.}

\item{polarity}{MS polarity; one of \code{VALID_MS_MODES} ("pos", "neg").}

\item{output}{Output file path (the function writes a tabular file here).}

\item{method}{Similarity method; one of \code{VALID_SIMILARITY_METHODS}.}

\item{threshold}{Minimal similarity score to retain candidates (0-1).}

\item{ppm}{Relative mass tolerance (ppm) for MS/MS matching.}

\item{dalton}{Absolute mass tolerance (Daltons) for MS/MS matching.}

\item{qutoff}{Intensity cutoff under which MS2 fragments are removed.
(Parameter name kept for backwards compatibility; spelled "cutoff").}

\item{approx}{Logical; if TRUE perform matching ignoring precursor masses
(broader, slower); if FALSE restrict library to precursor-tolerant
spectra first.}
}
\value{
Character scalar: the output file path (invisible). Side effect:
writes the annotations table to \code{output}.
}
\description{
Annotates MS/MS query spectra against one or more spectral
libraries, computing similarity scores and returning best candidate
annotations above a similarity threshold.
}
\details{
This is an orchestration wrapper that performs:
\enumerate{
\item Input validation & normalization (query + libraries, numeric params).
\item Query spectra import & light preprocessing (intensity cutoff).
\item Library spectra import, cleaning of empty peak lists, optional polarity
filtering, optional precursor-based library size reduction (when
\code{approx = FALSE}).
\item Similarity computation via \code{calculate_entropy_and_similarity()}.
\item Candidate metadata extraction (formula, name, etc.).
\item Result shaping: derive error (mz), select canonical output columns,
threshold filtering, keep best per (feature_id, library,
connectivity layer).
\item Export of parameters & results to the configured output path.
}

If no annotations are produced (empty inputs or below threshold), a
standardized empty template (see \code{fake_annotations_columns()}) is exported
to ensure downstream code receives expected columns.
}
\section{Robustness}{

The function performs strict validation and logs informative messages.
File existence is checked early; similarity computation is wrapped in a
\code{tryCatch} to surface errors without leaving partially allocated objects.
}

\section{Performance}{

Library precursor reduction (when \code{approx = FALSE}) limits similarity
computation to precursor-tolerant spectra, reducing complexity for large
libraries. Repeated metadata extraction uses a single vectorized helper.
}

\examples{
\dontrun{
copy_backbone()
go_to_cache()
get_file(
  url = get_default_paths()$urls$examples$spectra_mini,
  export = get_params(step = "annotate_spectra")$files$spectral$raw
)
get_file(
  url = get_default_paths()$urls$examples$spectral_lib_mini$with_rt,
  export = get_default_paths()$data$source$libraries$spectra$exp$with_rt
)
annotate_spectra(
  libraries = get_default_paths()$data$source$libraries$spectra$exp$with_rt
)
unlink("data", recursive = TRUE)
}
}
